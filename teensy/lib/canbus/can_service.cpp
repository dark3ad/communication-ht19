/**
 * @file can_service.cpp
 * @author Bengt Cruz (bengt.cruz@ya.se)
 * @brief The generated implementation of the CAN service.
 *        DO NOT EDIT THIS FILE BY HAND!
 * @version 0.1
 * @date 2020-11-10 12:45:33
 * 
 * @copyright Copyright (c) 2020
 * 
 */

#include <FlexCAN.h>
#include <can_signal.h>
#include <can_service.h>

#define BYTE_SIZE (8U)
#define BIT_RATE (250000)
#define WRITE_PER_READ (10U)

static void read_messages(void);
static void write_messages(void);

static CAN_message_t messages[] = {
	{.id = 0x100, .timestamp = 0, .flags = {.extended = 0, .remote = 0, .overrun = 0, .reserved = 0}, .len = 7, .buf = {0}},
	{.id = 0x101, .timestamp = 0, .flags = {.extended = 0, .remote = 0, .overrun = 0, .reserved = 0}, .len = 7, .buf = {0}},
	{.id = 0x102, .timestamp = 0, .flags = {.extended = 0, .remote = 0, .overrun = 0, .reserved = 0}, .len = 5, .buf = {0}},
	{.id = 0x103, .timestamp = 0, .flags = {.extended = 0, .remote = 0, .overrun = 0, .reserved = 0}, .len = 7, .buf = {0}},
	{.id = 0x104, .timestamp = 0, .flags = {.extended = 0, .remote = 0, .overrun = 0, .reserved = 0}, .len = 6, .buf = {0}},
	{.id = 0x105, .timestamp = 0, .flags = {.extended = 0, .remote = 0, .overrun = 0, .reserved = 0}, .len = 5, .buf = {0}},
	{.id = 0x106, .timestamp = 0, .flags = {.extended = 0, .remote = 0, .overrun = 0, .reserved = 0}, .len = 6, .buf = {0}}};

void can_signal_write(uint8_t msg_index, uint8_t start, uint8_t length, uint64_t value)
{
	uint8_t pos = start % BYTE_SIZE;
	uint8_t index = start / BYTE_SIZE;
	for (uint8_t i = 0; i < length; i++)
	{
		uint8_t bit = (uint8_t)((value >> i) & (uint64_t)1);

		messages[msg_index].buf[index] &= (~((uint8_t)1 << pos));
		messages[msg_index].buf[index] |= (bit << pos);

		pos++;
		if (pos % BYTE_SIZE == 0)
		{
			pos = 0;
			index++;
		}
	}
}

uint64_t can_signal_read(uint8_t msg_index, uint8_t start, uint8_t length)
{
	uint64_t value = 0;
	uint8_t pos = start % BYTE_SIZE;
	uint8_t index = start / BYTE_SIZE;

	for (uint8_t i = 0; i < length; i++)
	{
		uint64_t bit = ((uint64_t)(messages[msg_index].buf[index] >> pos) & (uint64_t)1);
		value |= (bit << 1);

		pos++;
		if (pos % BYTE_SIZE == 0)
		{
			pos = 0;
			index++;
		}
	}

	return value;
}

void can_service_init(void)
{
	CAN_filter_t filter;
	uint16_t rx_messages[] = {0x100, 0x101, 0x102, 0x103, 0x104, 0x105, 0x106};

	filter.id = 0x7FF;
	filter.flags.remote = 0;
	filter.flags.extended = 0;
	Can0.begin(BIT_RATE, filter);

	for (uint8_t i = 0; i < (sizeof(rx_messages) / sizeof(*rx_messages));i++)
	{
		filter.flags.remote = 0;
		filter.flags.extended = 0;
		filter.flags.reserved = 0;
		filter.id = rx_messages[i];
		Can0.setFilter(filter, i);
		Can0.setMask(~((uint32_t)0), i);
	}
}

void can_service_run(void)
{
	static uint8_t quanta = 0;

	quanta++;

	write_messages();

	if (quanta == WRITE_PER_READ)
	{
		read_messages();
		quanta = 0;
	}
}

static void read_messages(void)
{
	if (Can0.available())
	{
		CAN_message_t msg;
		while (Can0.read(msg))
		{
			for (uint8_t i = 0; i < (sizeof(messages) / sizeof(CAN_message_t)); i++)
			{
				if(msg.id == messages[i].id)
				{
					messages[i] = msg;
					break;
				}
			}
		}
	}
}

static void write_messages(void)
{
	uint8_t tx_messages[] = {1, 2, 3, 4, 5, 6};
	for (uint8_t i = 0; i < sizeof(tx_messages); i++)
	{
		Can0.write(messages[tx_messages[i]]);
	}
}